# 递归

> PaddyWang

所谓递归就是自己调用自己

递归思想就是：**将问题归结为已经解决的问题**

实现递归的过程：

*   什么时候递归
*   什么时候跳出

知识点：`arguments.callee`  就是当前函数的引用

上几个demo：

*   求`n!`

        function fn(n){
            if(n <= 0) return ; 
            if(n === 1) return 1;
            return arguments.callee(n - 1)*n;
        }
        console.log(fn(5));  //=> 120

**analyze：**

将问题归结为已经解决了的问题，求第`n`项的阶乘

假定已经有一个用于求阶乘的函数，即：函数本身

那么现在就可以求出第`n - 1`项的阶乘

然后用第`n - 1`项去乘以`n`，即`fn(n - 1)*n`就是`fn( n )`

结束条件，即：当`n`等于`1`的时候

*   求斐波那契数列（兔子数列）

        // 0, 1, 2, 3, 4, 5, 6...n
        // 1, 1, 2, 3, 5, 8, 13...
        function fn(n){
            if(n < 0) return ;
            if(n === 1 || n === 0) return 1;
            return arguments.callee(n - 2) + arguments.callee(n - 1);
        }
        console.log(fn(5));  // => 8

**analyze：**

将问题归结为已经解决的问题：

即：已经有一个可以求出第`n`项的斐波那契数列值

该数列的规律为：第`n`项是第`n - 1`与第`n - 2`项值的和

结束条件：第`1`项与第`0`项刚好为值`1`